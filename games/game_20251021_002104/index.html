<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Tic Tac Toe vs AI - PixiJS</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/8.13.2/pixi.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        h1 {
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }
        #gameContainer {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        #gameInfo {
            color: white;
            text-align: center;
            margin-top: 15px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        #resetBtn {
            margin-top: 15px;
            padding: 12px 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        #resetBtn:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        #resetBtn:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <h1>ðŸŽ® Tic Tac Toe vs AI</h1>
    <div id="gameContainer">
        <div id="gameInfo">Your turn! Click a cell to place X</div>
        <button id="resetBtn" onclick="resetGame()">ðŸ”„ New Game</button>
    </div>

    <script>
        // Game variables
        let app;
        let gameBoard = [
            [null, null, null],
            [null, null, null],
            [null, null, null]
        ];
        let currentPlayer = 'X'; // Player is X, AI is O
        let gameOver = false;
        let cells = [];
        let pixiGameContainer;
        let infoText;

        // Game constants
        const CELL_SIZE = 100;
        const GRID_SIZE = 3;
        const BOARD_SIZE = CELL_SIZE * GRID_SIZE;
        const LINE_WIDTH = 4;
        const SYMBOL_SIZE = 60;

        // Initialize the game
        async function init() {
            // Create PIXI application
            app = new PIXI.Application();
            
            // Initialize the application
            await app.init({
                width: BOARD_SIZE,
                height: BOARD_SIZE,
                backgroundColor: 0xffffff,
                antialias: true
            });

            // Add the canvas to the container
            const domGameContainer = document.getElementById('gameContainer');
            const existingCanvas = document.getElementById('gameCanvas');
            if (existingCanvas) {
                existingCanvas.remove();
            }
            domGameContainer.insertBefore(app.canvas, domGameContainer.firstChild);

            // Create game container
            pixiGameContainer = new PIXI.Container();
            app.stage.addChild(pixiGameContainer);

            // Initialize game elements
            createGrid();
            createCells();
            updateInfoText();
        }

        // Create the grid lines
        function createGrid() {
            const gridContainer = new PIXI.Container();
            pixiGameContainer.addChild(gridContainer);

            // Vertical lines
            for (let i = 1; i < GRID_SIZE; i++) {
                const line = new PIXI.Graphics();
                line.lineStyle(LINE_WIDTH, 0x333333, 1);
                line.moveTo(i * CELL_SIZE, 0);
                line.lineTo(i * CELL_SIZE, BOARD_SIZE);
                gridContainer.addChild(line);
            }

            // Horizontal lines
            for (let i = 1; i < GRID_SIZE; i++) {
                const line = new PIXI.Graphics();
                line.lineStyle(LINE_WIDTH, 0x333333, 1);
                line.moveTo(0, i * CELL_SIZE);
                line.lineTo(BOARD_SIZE, i * CELL_SIZE);
                gridContainer.addChild(line);
            }
        }

        // Create interactive cells
        function createCells() {
            cells = [];
            for (let row = 0; row < GRID_SIZE; row++) {
                cells[row] = [];
                for (let col = 0; col < GRID_SIZE; col++) {
                    const cell = new PIXI.Container();
                    cell.x = col * CELL_SIZE;
                    cell.y = row * CELL_SIZE;

                    // Create invisible clickable area
                    const hitArea = new PIXI.Graphics();
                    hitArea.beginFill(0x000000, 0);
                    hitArea.drawRect(0, 0, CELL_SIZE, CELL_SIZE);
                    hitArea.endFill();
                    hitArea.eventMode = 'static';
                    hitArea.cursor = 'pointer';
                    
                    // Add click handler
                    hitArea.on('pointerdown', () => handleCellClick(row, col));
                    
                    cell.addChild(hitArea);
                    cells[row][col] = cell;
                    pixiGameContainer.addChild(cell);
                }
            }
        }

        // Handle cell click
        function handleCellClick(row, col) {
            if (gameOver || gameBoard[row][col] !== null || currentPlayer !== 'X') {
                return;
            }

            // Place player's move
            makeMove(row, col, 'X');
            
            // Check for win/draw
            if (checkGameEnd()) {
                return;
            }

            // AI's turn
            currentPlayer = 'O';
            updateInfoText();
            
            // Delay AI move for better UX
            setTimeout(() => {
                makeAIMove();
                checkGameEnd();
            }, 500);
        }

        // Make a move on the board
        function makeMove(row, col, player) {
            gameBoard[row][col] = player;
            drawSymbol(row, col, player);
        }

        // Draw X or O symbol
        function drawSymbol(row, col, symbol) {
            const cell = cells[row][col];
            const centerX = CELL_SIZE / 2;
            const centerY = CELL_SIZE / 2;

            if (symbol === 'X') {
                // Draw X
                const x = new PIXI.Graphics();
                x.lineStyle(8, 0xff4444, 1);
                x.moveTo(centerX - SYMBOL_SIZE/2, centerY - SYMBOL_SIZE/2);
                x.lineTo(centerX + SYMBOL_SIZE/2, centerY + SYMBOL_SIZE/2);
                x.moveTo(centerX + SYMBOL_SIZE/2, centerY - SYMBOL_SIZE/2);
                x.lineTo(centerX - SYMBOL_SIZE/2, centerY + SYMBOL_SIZE/2);
                cell.addChild(x);

                // Add scale animation
                x.scale.set(0);
                const ticker = new PIXI.Ticker();
                let scale = 0;
                ticker.add(() => {
                    scale += 0.1;
                    x.scale.set(Math.min(scale, 1));
                    if (scale >= 1) {
                        ticker.destroy();
                    }
                });
                ticker.start();
            } else if (symbol === 'O') {
                // Draw O
                const o = new PIXI.Graphics();
                o.lineStyle(8, 0x4444ff, 1);
                o.drawCircle(centerX, centerY, SYMBOL_SIZE/2);
                cell.addChild(o);

                // Add scale animation
                o.scale.set(0);
                const ticker = new PIXI.Ticker();
                let scale = 0;
                ticker.add(() => {
                    scale += 0.1;
                    o.scale.set(Math.min(scale, 1));
                    if (scale >= 1) {
                        ticker.destroy();
                    }
                });
                ticker.start();
            }
        }

        // AI move logic
        function makeAIMove() {
            if (gameOver) return;

            const bestMove = getBestMove();
            if (bestMove) {
                makeMove(bestMove.row, bestMove.col, 'O');
                currentPlayer = 'X';
                updateInfoText();
            }
        }

        // Get best move for AI using minimax algorithm
        function getBestMove() {
            // First, try to win
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    if (gameBoard[row][col] === null) {
                        gameBoard[row][col] = 'O';
                        if (checkWinner() === 'O') {
                            gameBoard[row][col] = null;
                            return { row, col };
                        }
                        gameBoard[row][col] = null;
                    }
                }
            }

            // Second, block player from winning
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    if (gameBoard[row][col] === null) {
                        gameBoard[row][col] = 'X';
                        if (checkWinner() === 'X') {
                            gameBoard[row][col] = null;
                            return { row, col };
                        }
                        gameBoard[row][col] = null;
                    }
                }
            }

            // Third, take center if available
            if (gameBoard[1][1] === null) {
                return { row: 1, col: 1 };
            }

            // Fourth, take a corner
            const corners = [[0,0], [0,2], [2,0], [2,2]];
            for (let corner of corners) {
                if (gameBoard[corner[0]][corner[1]] === null) {
                    return { row: corner[0], col: corner[1] };
                }
            }

            // Finally, take any available space
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    if (gameBoard[row][col] === null) {
                        return { row, col };
                    }
                }
            }

            return null;
        }

        // Check for winner
        function checkWinner() {
            // Check rows
            for (let row = 0; row < GRID_SIZE; row++) {
                if (gameBoard[row][0] && 
                    gameBoard[row][0] === gameBoard[row][1] && 
                    gameBoard[row][1] === gameBoard[row][2]) {
                    return gameBoard[row][0];
                }
            }

            // Check columns
            for (let col = 0; col < GRID_SIZE; col++) {
                if (gameBoard[0][col] && 
                    gameBoard[0][col] === gameBoard[1][col] && 
                    gameBoard[1][col] === gameBoard[2][col]) {
                    return gameBoard[0][col];
                }
            }

            // Check diagonals
            if (gameBoard[0][0] && 
                gameBoard[0][0] === gameBoard[1][1] && 
                gameBoard[1][1] === gameBoard[2][2]) {
                return gameBoard[0][0];
            }

            if (gameBoard[0][2] && 
                gameBoard[0][2] === gameBoard[1][1] && 
                gameBoard[1][1] === gameBoard[2][0]) {
                return gameBoard[0][2];
            }

            return null;
        }

        // Check if board is full
        function isBoardFull() {
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    if (gameBoard[row][col] === null) {
                        return false;
                    }
                }
            }
            return true;
        }

        // Check if game has ended
        function checkGameEnd() {
            const winner = checkWinner();
            
            if (winner) {
                gameOver = true;
                if (winner === 'X') {
                    updateInfoText('ðŸŽ‰ You Win! Congratulations!');
                    highlightWinningLine(winner);
                } else {
                    updateInfoText('ðŸ¤– AI Wins! Better luck next time!');
                    highlightWinningLine(winner);
                }
                return true;
            } else if (isBoardFull()) {
                gameOver = true;
                updateInfoText('ðŸ¤ It\'s a Draw! Good game!');
                return true;
            }
            
            return false;
        }

        // Highlight winning line
        function highlightWinningLine(winner) {
            const winLine = new PIXI.Graphics();
            winLine.lineStyle(6, winner === 'X' ? 0xff4444 : 0x4444ff, 1);
            
            // Check rows
            for (let row = 0; row < GRID_SIZE; row++) {
                if (gameBoard[row][0] === winner && 
                    gameBoard[row][1] === winner && 
                    gameBoard[row][2] === winner) {
                    winLine.moveTo(10, row * CELL_SIZE + CELL_SIZE/2);
                    winLine.lineTo(BOARD_SIZE - 10, row * CELL_SIZE + CELL_SIZE/2);
                    pixiGameContainer.addChild(winLine);
                    return;
                }
            }

            // Check columns
            for (let col = 0; col < GRID_SIZE; col++) {
                if (gameBoard[0][col] === winner && 
                    gameBoard[1][col] === winner && 
                    gameBoard[2][col] === winner) {
                    winLine.moveTo(col * CELL_SIZE + CELL_SIZE/2, 10);
                    winLine.lineTo(col * CELL_SIZE + CELL_SIZE/2, BOARD_SIZE - 10);
                    pixiGameContainer.addChild(winLine);
                    return;
                }
            }

            // Check diagonals
            if (gameBoard[0][0] === winner && 
                gameBoard[1][1] === winner && 
                gameBoard[2][2] === winner) {
                winLine.moveTo(10, 10);
                winLine.lineTo(BOARD_SIZE - 10, BOARD_SIZE - 10);
                pixiGameContainer.addChild(winLine);
                return;
            }

            if (gameBoard[0][2] === winner && 
                gameBoard[1][1] === winner && 
                gameBoard[2][0] === winner) {
                winLine.moveTo(BOARD_SIZE - 10, 10);
                winLine.lineTo(10, BOARD_SIZE - 10);
                pixiGameContainer.addChild(winLine);
                return;
            }
        }

        // Update info text
        function updateInfoText(text = null) {
            const infoElement = document.getElementById('gameInfo');
            if (text) {
                infoElement.textContent = text;
            } else if (gameOver) {
                infoElement.textContent = 'Game Over';
            } else if (currentPlayer === 'X') {
                infoElement.textContent = 'Your turn! Click a cell to place X';
            } else {
                infoElement.textContent = 'AI is thinking... ðŸ¤”';
            }
        }

        // Reset the game
        function resetGame() {
            // Reset game state
            gameBoard = [
                [null, null, null],
                [null, null, null],
                [null, null, null]
            ];
            currentPlayer = 'X';
            gameOver = false;

            // Clear the stage and recreate
            if (app && app.stage) {
                app.stage.removeChildren();
                pixiGameContainer = new PIXI.Container();
                app.stage.addChild(pixiGameContainer);

                // Recreate game elements
                createGrid();
                createCells();
                updateInfoText();
            }
        }

        // Start the game when page loads
        window.addEventListener('load', () => {
            init().catch(console.error);
        });
    </script>
</body>
</html>